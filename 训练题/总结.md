## 总结

- 浏览器内核

  1. ie浏览器：Trident内核
  2. Chrome浏览器内核：以前是Webkit内核，现在是Blink内核
  3. Firefox浏览器内核：Gecko内核
  4. Safari浏览器内核：Webkit内核；
  5. Opera浏览器内核：最初是自己的Presto内核，后来是Webkit，现在是Blink内核；

- 什么是模块化开发

  **模块：**按照项目业务内容来划分大模块； 

  **组件：**按照一些小功能的通用性和可复用性来抽象组件； 

  一般来说，模块是由很多小组件组成的。虽然两者侧重点不同，但是从包含关系上讲，组件是模块的子集。

- 用过的es6有哪些

- extens原理

  class的内部是通过`Object.definePropterty`来定义的，对不同的属性做处理 如果是原型上的方法挂载Class.prototype 如果是静态方法放在 Class上

- webpack常用配置

  - html-webpack-plugin 配置html模版
  - webpack-dev-server 热更新
  - style-loader css-loader node-sass sass-loader等，把不同的文件都转成JS文件

- commonJS规范

- node.js你都拿来做什么

  > 1. 做日常shell工具，因为node可以操作文件 balala
  > 2. 做脚手架工具
  > 3. 做api服务/web框架

- node常用模块

  - buffer
  - fs

- promise原理

- rem原理 dpr

  - 使用rem布局，实质都是通过动态改写html的font-size基准值，来实现不同设备下的良好统一适配；**1em**，就是这个元素上的 **font-size** 的值，如果元素本身没有设置 **font-size** ，就按照他的父级的 **font-size** 计算（其实本身的font-size继承了父级的font-size）

    ```javascript
    // 把rem计算放到body头部，目的是为了保证css导入后才执行这段js(不写在index中而是写在页面中，就是为了保证这段程序加载速度快一些，没必要等到合并的JS加载，先把样式处理了)
    ;(function anonymous(){
        function computed(){
            let HTML=document.documentElement,
                winW=HTML.clientWidth,
                desW=750;
            if(winW>=desW){
                HTML.style.fontSize='100px';
                return;
            }
            HTML.style.fontSize=winW/750*100+'px';
        }
        computed();
        window.addEventListener('resize',computed,false);
    })()
    ```

  - **dpr是**设备像素比的意思，网页的视口的大小是设备分辨率/dpr

- document的ready事件通常会比window的onload事件先发生，为什么呢？

  > 因为document的ready是在浏览器加载解析并构建完doc文档模型时发生的，而window.onload必须等到页面内包括图片的所有元素加载完毕后才能执行。

- 当我们在浏览器中输入一个URL地址，到最后看到页面，都经历了哪些事情？

  **[Request请求阶段]** 客户端通过一系列方式找到服务器

  1、首先根据客户端输入的域名，到DNS服务器上进行反解析（通过域名找到对应服务器的外网IP）

  2、通过找到的外网IP，找到对应的服务器

  3、通过在地址中输入的端口号（没输入是因为不同协议有自己默认端口号）找到服务器上发布的对应的项目

  **[Response 响应阶段]** 服务器接收到请求 把东西返回给客户端

  4、服务器获取到请求资源文件的地址，`例如:/stu/index.html`，把资源文件中的`源代码`找到

  5、服务器会把找到的源代码返回给客户端（通过HTTP等传输协议返回的）

  **[浏览器自主渲染]**

  6、客户端收到源代码后，会交给浏览器的内核（渲染引擎）进行渲染，最后由浏览器绘制出对应的页面

- Ajax的原理，你平常怎么发送网络请求的

  > 通过XMLHttpRequest/ActiveXObject新建Ajax请求
  >
  > 通过onreadystatechange注册回调函数
  >
  > 使用open、setRequestHeader、send结合发送请求
  >
  > 平常发送网络请求：用next做同构应用时，使用`isomorphic-fetch`发送请求，如果只是客户端发送请求时，使用`axios`

- JS中常用的设计模式

  单例设计模式、构造原型设计模式、发布订阅设计模式、promise设计模式

- 前端常用的优化方法

  - 减少HTTP请求的次数或者减少请求数据的大小
    - 雪碧图
    - 压缩CSS/JS
    - 延迟加载
    - 对于不经常更新的数据，最好采用浏览器的304缓存做处理。对于客户端来讲，我们还可以基于localStorage来做一些本地存储
  - 编写代码优化技巧
    - 减少对DOM的操作
    - 使用异步编程
    - CSS选择器优化
  - SEO优化技巧
    - 页面杜绝出现死链接
    - 避免浏览器中异常错误的抛出

- JS本身是单线程的，那浏览是怎么处理异步的

  js本身是单线程的，但是他所处的环境是多线程的。浏览器环境，node环境都是多线程的，他所在的环境帮他维护了 evet loop。

## react

- 什么是 JSX 和我们怎样在 JavaScript 代码中书写它 —— 浏览器是如何识别它的？

  > JSX 只是一种 Facebook 普及的标记语法，受益于 Babel/TSC 这些工具。我们能够以一种更令赏心悦目的方式书写 `React.createElement` 调用。

- babel和react什么关系

  > babel遇见jsx语法，会自动调用React.createELement返回一个虚拟dom，jsx是React.createELement的一个语法糖

- 为什么 JSX 中的组件名要以大写字母开头

  > React 如何知道要渲染的是组件还是 HTML 元素就够了。

- 你能解释下“状态提升”理念吗？

  > 它允许你在兄弟组件间传递数据，允许你拥有更多纯展示组件，更易复用。

- 如果不能在组件间传递数据，你怎样给多级组件传递数据？

  > 自从 React 16.3 开始，Context 已经成为主流 —— 它之前就已经存在了，不过文档是缺失的（有意为之）。如果能在解释出 Context 的工作方式（同时能表现出知道 function-as-child 模式）会是加分项。

- react中各个生命周期一般会处理什么逻辑

  - componentDidMount、componentWillMount用来处理页面页面初始化的数据
  - componentWillUnmount组件销毁的时候处理一些定时器 事件挂载的逻辑
  - shouldComponentUpdate 处理组件接收新的state和props

- react做项目中遇到过什么问题
  - 基于render返回的组件不是受路由管控的组件，组件要用withRouter
  - 路由切换跳转页面，组件没有重新渲染。如果当前组件之前没有彻底在页面中移除（本组件内容的子组件在切换），每一次走的是更新的流程，不是重新挂载的流程

## CSS

- css三角形

  每个border都是一个梯形，把div元素的宽变为0。

  ```css
  #demo{
               width:0px;  
               height:0px;  
               border:40px solid transparent;
               border-bottom:80px solid red;
          }
  ```
