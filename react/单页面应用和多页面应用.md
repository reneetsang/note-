## SPA和MPA

### 单页面应用和多页面应用

**单页面web应用 SPA**：single page web application 

一个项目只有一个页面，所有内容展示和业务都在这一个页面中实现切换，webpack中只需要配置一个入口即可（移动端单页面居多或者pc端管理系统类也是单页面应用为主）

**多页面web应用 MPA**：multi page web application 

一个项目包含很多页面，通过页面之前的跳转完成业务逻辑的衔接等（PC端多页面应用居多）：基于框架开发的时候，需要在webpack中配置多入口，每一个入口对应一个页面

### 如何实现单页面应用？

1. 如果项目是基于服务器渲染的，后台语言中可以基于"include"等技术，把很多部分拼凑在一起，实现组件化或者插件化开发，也可以实现单页面应用

2. 基于iframe实现单页面应用

3. 模块化开发

   - AMD:require.js
   - CMD:sea.js

   基于这些思想把每一部分单独写成一个模块，最后基于grunt/gulp/fis等自动化工具，把最后所以模块都合并到首页面中（包括HTML,CSS,JS都合并在一起），通过控制哪些模块隐藏单页面应用开发

   弊端：由于首页中的内容包含了所有模块的信息，所以第一次加载速度很慢（虽然可以解决，但相对来说比较麻烦）

4. 基于vue/react实现模块化组件化开发，基于他们提供的路由实现SPA单页面应用，基于webpack打包等

|                            | 多页面应用MPA                                        | 单页面应用SPA                                                |
| -------------------------- | ---------------------------------------------------- | ------------------------------------------------------------ |
| 应用组件                   | 由多个完整页面构成                                   | 一个外壳页面和多个页面片段构成                               |
| 跳转方式                   | 页面之间的跳转是从一个页面跳转到另一个页面           | 页面片段之间的跳转是把一个页面片段删除或者隐藏，加载另一个页面片段并显示出来。这是片段之间的模拟跳转，并没有离开壳页面 |
| 刷新方式                   | 整页刷新                                             | 页面片段局部刷新                                             |
| 跳转后公共资源是否重新加载 | 是                                                   | 否                                                           |
| URL模式                    | http://xxx/page1.html                                | http://xxx/shell.html#page1                                  |
| 用户体验                   | 页面间切换加载慢，不流畅，用户体验差，特别在移动端上 | 页面片段间的切换快，用户体验好，包括在移动设备上             |
| 能否实现转场动画           | 无法实现                                             | 容易实现                                                     |
| 页面间传递数据             | 依赖url、cookie、或者localStorage，实现麻烦          | 因为在一个页面内，页面片段间传递数据容易实现                 |
| 搜索引擎优化（SEO）        | 可以直接做                                           | 需要单独方案做，有点麻烦                                     |
| 特别适用的范围             | 需要对搜索引擎友好的网站                             | 对体验要求高的应用，特别好似移动应用                         |
|                            |                                                      |                                                              |
|                            |                                                      |                                                              |
|                            |                                                      |                                                              |

## 使用react路由实现SPA

1. 安装路由 $ yarn add react-router-dom

   3及以前版本称为react-router

   4及最新版本称为react-router-dom

2. 学习react路由 reacttraining.cn/web/api

3. BrowserRouter VS HashRouter

   它是两种常用的路由实现思想，BrowserRouter浏览器路由，HashRouter哈希路由

### BrowserRouter

它是基于H5中的historyAPI(pushState,replaceState,popState)来保持UI和URL的同步，真实项目中应用的不多，一般只有当前项目是基于服务器渲染的，我们才会使用浏览器路由

http://www.demo.com/

http://www.demo.com/personal/

http://www.demo.com/personal/login/

### HashRouter

- 真实项目中（前后端分离的项目：客户端渲染），我们经常使用的哈希路由来完成的，它依据相同的页面地址，不同的哈希值，来规划当前页面中的哪一个组件呈现渲染，它基于原生JS构造了一套类似于history API的机制，每一次路由切换都是基于history stack完成的。

  http://www.demo.com/#/

  http://www.demo.com/#/personal/

1. 当前项目一旦使用hash-router，则默认在页面的地址后面加上#/，也就是hash默认值是一个斜杠，我们一般让其现实首页组件信息内容
2. hash-router中只能出现一个子元素
3. hash-router机制中，我们需要根据哈希地址不同，展示不同的组件内容，此时需要使用Route

###　Route

- path：设置匹配地址，但是默认不是严格匹配，当前页面哈希地址只要包含完整的它（内容是不变的）都能被匹配上
  - path='/'：和它匹配的地址只要有斜杠即可（都能和它匹配）
  - path='/user'：path='/user/login'也可以匹配，但是path='/user2'无法匹配
- component：一旦哈希值和当前route的path相同了，则渲染component指定的组件
- exact：让path的匹配严谨和严格一些（只有url哈希值和path设定的值相等才可以匹配到）
- render：当页面的哈希地址和path匹配，会把render规划的方法执行，在方法中一般做“权限校验”（渲染组件之前验证是否存在权限，不存在做一些特殊处理）

```react
import React from 'react';
import ReactDOM,{render} from 'react-dom';
import {HashRouter,Route} from 'react-router-dom';


render(<HashRouter>
        <div>
            <Route path='/' exact component={A} />
            <Route path='/user' component={B} />
            <Route path='/pay' render={()=>{
                    // 一般在render中处理的是权限校验
                    let flag=localStorage.getItem('FLAG');
                    if(flag && flag ==='safe'){
                        return <C />;
                    }
                    return '当前环境不安全，不利于支付'
                }} />
        </div>        
</HashRouter>,root)
```

