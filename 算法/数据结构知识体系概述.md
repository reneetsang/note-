## 数据结构知识体系概述

### 基本描述

1. 数据项:数据结构中讨论的最小单位
2. 数据结构是一个二元组:数据元素和关系
3. 数据机构分为四大类:
   - a.线性结构
   - b.树形结构
   - c.图状结构
   - d.集合结构
4. 结构划分:
   - a.逻辑结构
   - b.物理结构
5. 存储结构:
   - a.顺序结构
   - b.链式结构
6. 抽象数据类型ADT: 核心是数据抽象和数据封装,内部实现分为三个部分
   - a.数据对象:数据的一个子集
   - b.数据关系:数据之间的关系
   - c.数据操作:数据的操作

### 算法

1.算法的特性

```
    - 有穷性:算法在执行**有限次数**之后结束,在**有限时间**之内完成
    - 确定性:算法的每一步执行的过程需要明确
    - 可行性:算法是可行的
    - 输入:0个或多个输入
    - 输出:一个或多个输出
```

2.算法的设计目标

```
    - 正确:
    - 可读:算法主要是人的阅读与交流,其次才是计算机的执行,应该是**易于理解**的
    - 健壮:算法应该是对非法的操作进行相应的处理,而不是产生莫名其妙的输出
    - 高效率与低存储:算法的执行时间和算法的占用空间
```

3.算法的效率的衡量

```
    - a.事后统计的方式
    - b.事前分析估算的方式
```

4.执行时间相关:

```
    - a.算法选用的策略
    - b.问题的规模: 决定了**运行的工作量**,即**时间复杂度**
    - c.编写的语言
    - d.编译程序产生的及其代码的质量
    - e.计算机指令的执行速度
```

5.时间复杂度:

> 时间复杂度与算法执行的次数(问题的规模)成正比

6.算法的存储空间

> 算法的存储量包括三个部分: 输入数据的空间,存储本身的空间.辅助变量的空间

7.算法的空间复杂度

> 随着问题规模的增大,算法的空间复杂度的增长率与问题的规模的增长率相同

------

### 线性表

> 线性表分为顺序结构和链式结构

1.顺序结构:类比于数组

> 1. 查找算法:查找指定位置的元素,查找到,返回元素值,差找不到,返回-1 indexOf
> 2. 插入算法:判断插入的位置是否合法,合法即插入,倒序的方式 unshift push
> 3. 删除算法:删除指定位置的元素,删除成功,返回删除的值 shift pop
> 4. 合并算法:将两个数组合并 concat

2.链式结构之单链表 通常情况下,为了操作方便,通常在第一个节点的头部添加一个虚拟的头结点 **单链表是一种顺序存取的结构**

> 1. 查找算法:顺序存取,为了查找到指定的元素需要从头开始遍历
>
> 2. 插入算法:查找到指定的位置,直接断开指针插入数据,在恢复指针的指向
>
> 3. 删除算法:查找到指定的位置,修改指针的指向,再删除元素
>
> 4. 单链表的生成(建立):数据的逐个插入,分为头插法和尾插法
>
>    > 头插法:从头部开始插入元素
>    >
>    > 尾插法:从尾部开始插入元素
>
> 5. 链表的长度:遍历链表,查找非空指针
>
> 6. 单链表的合并:遍历一个链表到尾部,修改尾部指针指向另一个链表的头部

3.链式结构之单循环链表:同样有头部节点和尾部节点 修改单链表的尾部指针指向头部

> 合并算法:两个链表的首位连接

4.链式结构之双链表:通常以循环链表的形式实现

5.链式结构值双向循环链表

6.链表的特点总结

```
- 1.链表是一种动态分配空间的存储结构,能够更有效的分配空间
- 2.链表以指针作为数据连接的纽带,在插入删除数据时不需要移动元素
- 3.链表是**顺序存取**的结构,在随机存取和表尾插入的时候会带来不便
- 4.链表的长度时隐含值,给线性表的操作带来不便
- 5.链表中节点的位序不明确
```

### 栈和队列:受限的线性表

> 栈:只能在头部进行相关的数据操作
>
> 队列:只能在尾部进行相关的数据操作

**栈的应用**

1. 数制转换: N = parseInt(N/d)+ N%d 将N%d输出
2. 括号匹配的检验
   - 凡出现左括号,就进栈
   - 凡出现右括号,在栈不为空的情况下,进行栈顶匹配
   - 匹配成功,左括号出栈
3. 迷宫求解
   - 当前位置可通,将当前的位置插入栈顶
   - 当前位置不可通,后退一步,继续前进
   - 当四周均无通路,将当前位置从栈顶删除
   - 
4. 表达式求值
5. 实现递归

**栈的分类**

1. 顺序栈(数组的形式)
2. 链栈(链表)

**队列的应用**

1. 逐项输出前n项的二项式系数

**队列的分类**

1. 链队列
2. 循环队列

------

### 串/字符串

> 是一个有限长的字符序列

1.串的定长存储

> 在插入和删除单个字符和字符串的时候需要判断插入的位置是否合法,
>
> > 插入后串的长度是否合法以及超出部分截取的取舍

2.串的堆分配存储

> 使用一块连续的存储空间在程序实行的过程中使用**new**关键字动态分配得到
>
> > 所有的变量都存储在一个称为**堆**的共享空间中

3.串的块链存储表示

> 串的数据元素是一个字符,只有八位二进制数, 通常一个链节点中存储的不是一个字符,而是一个子串
>
> > **存储密度** = 数据元素所占的空间 **/** 实际分配的存储位

4.**串的操作**:在操作之前,需要尽心一系列的判断

```
- 1.插入:
- 2.删除:
- 3.复制
- 4.判空
- 5.比较
- 6.求长
- 7.清空
- 8.连接
- 9.求子串
```

------

### 数组和广义表

**矩阵**:**数组的二维表示**

**稀疏矩阵:**矩阵的**稀疏因子<=0.05 矩阵的稀疏因子:**非0元素的个数/元素的总个数

稀疏矩阵计算的时候存在的问题:

> 稀疏矩阵的**非0值与其计算**占据了**很大一部分空间**

稀疏矩阵的压缩存储:

1. 三元组顺序表:非0元在表中按照行序有序存储
2. 行逻辑联接的顺序表:
3. 十字链表

**广义表**:是一种非非线性结构,是线性表的一种推广

> 是一个递归定义的线性结构
>
> 是一个多层次的线性结构

**递归的求解**分而治之的算法思想,将足够复杂的算法分解简单化

1. 广义表的数据可以是单个元素,可以使一个线性表,也可以是广义表的一个子表 2.两种广义表的运算
   - 头尾链表存储结构:分解成表头,表尾两部分
   - 扩展线性存储:将广义表分解为n个子表

### 树和二叉树

**树的分类**

1. 有向树:有确定的根,树根和子树根之间为有向关系
2. 有序树:子树之间存在着确定的次序关系
3. 无序数:子树之间不存在确定的次序关系

**基本术语**

1. 节点:数据元素+指向若干子树的分支
2. 节点的度:分支的个数
3. 树的度:树中的所有的节点的度的做大致
4. 叶子节点:度为0的节点
5. 分支节点:度大于0的节点
6. 节点的层次:根节点为第一层(也有看作是第0层)
7. 树的深度:树中的叶子节点所在的最大层次
8. 树林:m棵树不相交的树的集合

**二叉树**:有五种基本的形式

1. 空树
2. 只有根节点的树
3. 左子树存在,右子树不存在
4. 左子树不存在,右子树存在
5. 左右子树都存在

**二叉树的特性**

1. 在第i层上最多有2(N-1)次方个节点
2. 深度为k的二叉树最多含有2(K)次方-1个节点
3. 二叉树,n0个叶子节点,n2个度为2的节点,必然存在关系n0=n2+1
4. 含有n个节点的树的深度|log2n|+1

**两类特殊的二叉树**

1. 满二叉树:二叉树含有最多的节点
2. 完全二叉树:树中的n个节点和编号为1-n的节点一一对应

**二叉树的存储结构**

1. 顺序存储:对二叉树的节点进行标号兵分配空间,空节点同样要进行编号bong分配空间
2. 链式存储
   - 二叉链表:每个节点都有左右指针
   - 三叉链表:在二叉链表的基础之上,增加一个指向父节点的指针
   - 双亲链表:对节点进行编号,节点中保存着父节点的编号以及本身是左子还是右子

**二叉树的遍历**

1. 先(序)根遍历:先遍历根节点,再遍历左子树,后遍历右子树
2. 中(序)根遍历:先遍历左子树,再遍历根节点,后遍历右子树
3. 后(序)根遍历:先遍历左子树,再遍历右子树,后遍历根节点

**赫夫曼树和最优树**

1.最优树:**所有的叶子节点**的带权路径长度的**最小值**

> 最优树的特点:左子节点小于右子节点,根节点的值最大

2.赫夫曼算法:构造最优树的算法

```
- 先将权值序列进行升序排序,从左往右两两结合相加,若有剩余,先不做处理
- 将相加得到的和的序列重新进行排序(算上剩余的权值),再两两相加,重复此步骤
```

3.赫夫曼编码:最优前缀码

> 对最优树进行二进制序列的编码
>
> > 可以使所传的电文的总长度最短

### 图

> 通俗来说,图是有点和线构成的

**专业术语:**

1. 有向图:线有方向
2. 无向图:线无方向
3. 网:线带权的图称为网,分为有向网和无向网
4. 完全图:含有**n(n-1)/2**条边的无向图
5. 有向完全图:含有**n(n-1)**条边的有向图
6. **稀疏图与稠密图:**以**nlogn**为分界线
7. **度**:与点相关联的边的数目
8. 出度和入度:对于有向图而言的度
9. 路径:两点之间的通路,类比于两地之间的路线
10. 路径长度:路径上边的数目,类比于两地之间相隔于哪些地点(哪些段路径)
11. 简单的路径:路径中不存在重复的点
12. 简单的回路:路径中的第一个点和最后一个点相同
13. **连通图**:图中的任意两个点之间都有路径相通
14. **连通分量**:若无向图为非连通图,则图中的极大连通子图称为连通分量
15. **强连通图**:对于有向图而言,任意两个点之间都能够连通
16. **强连通分量**:对于非强连通图,图中的极大强连通子图称为强连通分量
17. **生成树**:**连通图**中的**n个顶点和n-1**条边构成的**极小连通子图**
18. **生成森林**:**非连通图**的各个联通分量的生成树
19. **双(重连通图):从连通图中删除任意一个顶点和边,仍然是一个连通图**
20. 关节点:连通图中某个顶点和相关联的边被删除后,该连通图被分割为两个或两个以上的连通分量,则称此点位关节点,**没有关节点的连通图为双连通图**

**图的存储**

1. 图的数组(邻接矩阵)存储
   - 无向图邻接矩阵是对称的
   - 有向图的邻接矩阵在正常情况下是非对称的
2. 图的邻接表存储
   - 对图中的点进行编号,点的指针指向对应的点的编号

**3. 有向图的十字链表存储** **4. 无向图的邻接多重表存储**

**图的遍历**

1. 深度优先搜索:类似于树的先根遍历
2. 广度优先搜索:分层搜索

**最小生成树**:指的是连通图

> 问题描述:求两地之间的最短路径
>
> 即求权值之和最小的通路

1.普里姆算法求最小生成树

> 取图中的任意一个顶点作为起点,逐渐添加顶点和边,添加边的时候选取权值最小的边
>
> > 注意:添加顶点的时候要选取权值最小的边
>
> **时间复杂度:n2,适用于稠密图**

2.克鲁斯卡尔算法求最小生成树

> 构造一个含有n个顶点的子图,在不形成回路的情况下依次添加权值最小的边
>
> **时间复杂度为eloge,适用于稀疏图**

**3. 深度优先生成树**

**4. 两点之间的最短路径问题**

**5. 拓扑排序**

> 检测有向图中是不是存在回路:对有向图进行拓扑排序

```
- 拓扑排序的方式:
   - 1.选取一个没有前驱(入度为0)的节点,并输出
   - 2.从有向图中删除这个节点以及相连的边
   - 3.重复上述两个步骤,直到没有顶点为止
```

**6. 关键路径和活动**

> 以施工为例:子项工程的进度会影响整个工期的完成期限
>
> 关键路径:起点到终点的最长路径
>
> 关键活动:权值增加,最长路径增加
>
> 映射到生活中:关键活动增加,会导致关键路径增长,而影响最终的工期

### 查找表

> 查找表示同一类型的数据(记录)构成的集合

**操作**

1. **查找**某个**特定的**数据元素是否在查找表中
2. **检索**某个**特定的**数据元素的各种属性
3. 在查找表中**插入**一个数据元素
4. 在查找表中**删除**一个数据元素

**关键字**

1. 主关键字:查找表的唯一主键

2. 次关键字:可以识别若干记录

   > 根据关键字可以查询查找表中的数据

**查找表的分类**

1. 静态查找表
   - 1.顺序表或线性链表
     - 时间性能 n+1 / 2
     - 不适合大数据的查找
   - 2.有序查找表:等概率情况下
     - 折半查找:时间性能log2(n+1)-1
     - 不适合不等概率的查找
   - 3.静态查找树
     - 类比于折半查找,不过在性能上更优于折半查找
   - 1. 索引顺序表
        - 在建立表的同时,建立索引
2. 动态查找表
   - 1.二叉排序树
     - 数据从小到达排列:左中右
   - 2.二叉平衡树
     - 左右结点的深度之差不大于1,数据按照二叉排序树进行
   - 3.B - 树
     - 平衡树的多路查找
   - 1. B + 树
        - b树的一种变形
   - 1. 键树
        - 双链树和Trie树
3. 哈希表

### 排序

**内部排序**

> 整个排序过程在内存中进行,不需要访问外存

1. 插入类
   - 1.直接插入排序:基于顺序查找
   - 2.折半插入排序:基于折半查找,数据未有序序列
   - 3.表插入排序:基于链表存储,减少移动的次数
   - 4.希尔插入排序:基于逐趟缩小增量
     - 定义一个增量,逐渐减小,根据增量进行数据的比较,
     - 进行逐趟排序,直到增量减小到1
2. 交换类
   - 1.冒泡(起泡)排序:比较相邻的记录,无序则交换
   - 2.快速排序:设定键值,将排序的数列分为左右两部分,依次进行
   - 
3. 选择类
   - 1.简单的选择排序:选择最值,放到首位
   - 2.堆排序:完全二叉树:任意一个根节点均布大于其左右孩子节点,并且左小于右
4. 归并类
   - 归并排序:将数据划分成一个个小块,进行比对,逐渐合并
5. 其他
   - 1.基数排序
     - 多关键字的排序
     - 链式基数排序
   - 2.

**外部排序**

> 若排序的数据量很大,不能在内存中进行,称为外部排序

外部排序分为两个相对独立的步骤来完成

1. 按照可用内存大小进行分配,构造若干有序的子序列,
2. 通过归并,逐渐扩大有序子序列的长度